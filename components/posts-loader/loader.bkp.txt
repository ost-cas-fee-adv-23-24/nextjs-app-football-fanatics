'use client';
import React, { useCallback, useEffect, useRef, useState } from 'react';
import { PostCard } from '@/components/post-card/PostCard';
import { IPostItem } from '@/utils/interfaces/mumblePost.interface';
import PostActionsBar from '@/components/post-actions-bar/PostActionsBar';
import usePosts from '@/hooks/usePosts';
import { EPostsActions } from '@/stores/Posts.context';
import { PostEditorPlaceholder } from '@/components/placeholders/PostEditorPlaceholder';
interface IProps {
  userIdentifier?: string;
  isLikes?: boolean;
  creators?: string[];
}

const PostsLoaderBkp = ({
  userIdentifier,
  isLikes = false,
  creators,
}: IProps) => {
  const {
    posts,
    isLoading,
    nextMumblePostsUrl,
    dispatchPosts,
    fetchPostsBatch,
  } = usePosts();
  const numRows = posts.length;
  const [scrollTop, setScrollTop] = useState(0);
  const [availableHeight, setAvailableHeight] = useState(0);
  const rowHeight = 100;
  const totalHeight = rowHeight * numRows;
  const containerRef = useRef(null);
  let startIndex = Math.floor(scrollTop / rowHeight);
  let endIndex = Math.min(
    startIndex + Math.ceil(availableHeight / rowHeight) + 1,
    numRows,
  );

  const renderSinglePost = (post: IPostItem, index: number) => {
    return (
      <div
        ref={posts.length === index + 1 ? lastPostRef : undefined}
        className="bg-white py-8 px-12 relative rounded-2xl mb-6 w-full"
        key={post.id}
        data-identifier={post.id}
      >
        <PostCard
          key={`${post.id}`}
          text={post.text}
          id={post.id}
          creator={post.creator}
          mediaUrl={post.mediaUrl}
          mediaType={post.mediaType}
          likes={post.likes}
          replies={post.replies}
          likedBySelf={post.likedBySelf}
        />
        <div className="mt-3 ml-[-12px]">
          <PostActionsBar
            creatorIdentifier={post.creator.id}
            identifier={post.id}
            amountLikes={post.likes}
            amountComments={post.replies}
            selfLiked={post.likedBySelf}
          />
        </div>
      </div>
    );
  };

  useEffect(() => {
    // @ts-ignore
    setAvailableHeight(containerRef.current.clientHeight || 0);
  }, []);

  useEffect(() => {
    fetchPostsBatch();
    return () => {
      dispatchPosts({
        type: EPostsActions.RESET,
        payload: null,
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const observer = useRef();

  const lastPostRef = useCallback(
    (node: any) => {
      if (observer.current) {
        // @ts-ignore
        observer.current.disconnect();
      }
      // @ts-ignore
      observer.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && !isLoading) {
          if (nextMumblePostsUrl) {
            fetchPostsBatch(nextMumblePostsUrl);
          }
        }
      });
      if (node) {
        // @ts-ignore
        observer.current.observe(node);
      }
    },
    [
      isLoading,
      userIdentifier,
      nextMumblePostsUrl,
      dispatchPosts,
      creators,
      isLikes,
    ],
  );

  const postsToRender = [];
  let index = startIndex;

  while (index < endIndex) {
    const currentPost = posts[index];
    postsToRender.push(renderSinglePost(currentPost, index));
    index++;
  }

  return (
    <div className="posts-container grow overflow-hidden flex flex-col">
      <div
        className="overflow-y-scroll grow"
        ref={containerRef}
        onScroll={(evt) => {
          const target = evt.target as HTMLTextAreaElement;
          setScrollTop(target.scrollTop);
        }}
      >
        <div
          className="global-width mx-auto"
          style={{
            height: totalHeight,
            paddingTop: startIndex * rowHeight,
          }}
        >
          {posts.length === 0 && <PostEditorPlaceholder />}
          {postsToRender}
          {isLoading && <PostEditorPlaceholder />}
        </div>
      </div>
    </div>
  );
};

export default PostsLoaderBkp;
